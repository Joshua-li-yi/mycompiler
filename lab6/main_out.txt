lno@0  @0  NODE PROG    children:[@1 @4 @7 ]
lno@1  @1  NODE STMT  STMT DECL  children:[@2 @3 ]
lno@1  @2  NODE TYPE  int  children:[]
lno@1  @3  NODE VAR  var name: a  children:[]
lno@2  @4  NODE STMT  STMT DECL  children:[@5 @6 ]
lno@2  @5  NODE TYPE  int  children:[]
lno@2  @6  NODE VAR  var name: b  children:[]
lno@3  @7  main    children:[@8 @9 ]
lno@3  @8  NODE TYPE  int  children:[]
lno@3  @9  NODE STMT  STMT DOMAIN  children:[@10 @16 @22 @31 @36 ]
lno@5  @10  NODE STMT  scanf  children:[@11 @13 ]
lno@5  @11  NODE EXPR  OP: EXPR combine  children:[@12 ]
lno@5  @12  NODE CONST  string: "%d"  children:[]
lno@5  @13  NODE EXPR  OP: EXPR combine  children:[@14 ]
lno@5  @14  NODE EXPR  OP: &  children:[@15 ]
lno@5  @15  NODE VAR  var name: a  children:[]
lno@6  @16  NODE STMT  scanf  children:[@17 @19 ]
lno@6  @17  NODE EXPR  OP: EXPR combine  children:[@18 ]
lno@6  @18  NODE CONST  string: "%d"  children:[]
lno@6  @19  NODE EXPR  OP: EXPR combine  children:[@20 ]
lno@6  @20  NODE EXPR  OP: &  children:[@21 ]
lno@6  @21  NODE VAR  var name: b  children:[]
lno@6  @22  NODE STMT  STMT IF  children:[@23 @27 ]
lno@6  @23  NODE EXPR  OP: EXPR combine  children:[@24 ]
lno@7  @24  NODE EXPR  OP: ==  children:[@25 @26 ]
lno@7  @25  NODE VAR  var name: a  children:[]
lno@7  @26  NODE VAR  var name: b  children:[]
lno@6  @27  NODE STMT  STMT DOMAIN  children:[@28 ]
lno@9  @28  NODE STMT  printf  children:[@29 ]
lno@9  @29  NODE EXPR  OP: EXPR combine  children:[@30 ]
lno@9  @30  NODE CONST  string: "Success\n"  children:[]
lno@9  @31  NODE STMT  STMT ELSE  children:[@32 ]
lno@9  @32  NODE STMT  STMT DOMAIN  children:[@33 ]
lno@13  @33  NODE STMT  printf  children:[@34 ]
lno@13  @34  NODE EXPR  OP: EXPR combine  children:[@35 ]
lno@13  @35  NODE CONST  string: "Failed\n"  children:[]
lno@15  @36  NODE STMT  STMT RETURN  children:[@37 ]
lno@15  @37  NODE EXPR  OP: EXPR combine  children:[@38 ]
lno@15  @38  NODE CONST  int: 0  children:[]

==========symbol table=======
name: a token: 3 type: 0
name: b token: 6 type: 0
name: main token: 7 type: 1
name: .LC0 token: 12 type: 10
name: .LC1 token: 18 type: 10
name: .LC2 token: 30 type: 10
name: .LC3 token: 35 type: 10
===========================
	   Operator   	arg1	arg2	result
0	VAR_DECL		-	-	a	
1	VAR_DECL		-	-	b	
2	MAIN		-	-	main	
3	CITE		a	-	t0	
4	PUSH		-	-	t0	
5	PUSH		-	-	.LC0	
6	SCANF		-	-	-	
7	CITE		b	-	t1	
8	PUSH		-	-	t1	
9	PUSH		-	-	.LC1	
10	SCANF		-	-	-	
11	EQU		a	b	t2	
12	IF		-	-	t2	
13	JLE		-	-	.L0	
14	PUSH		-	-	.LC2	
15	PRINTF		-	-	-	
16	JUMP		-	-	.L2	
17	LABEL		-	-	.L0	
18	PUSH		-	-	.LC3	
19	PRINTF		-	-	-	
20	LABEL		-	-	.L2	
21	RETURN		-	-	-	

# your asm code header here
	.file	./src/tree.cpp
	.text
	.bss
	.global	a
	.align	4
	.type	a, @object
a:
	.zero	4
	.global	b
	.align	4
	.type	b, @object
b:
	.zero	4
	.section	.rodata
.LC0:
	.string	"%d"
.LC1:
	.string	"%d"
.LC2:
	.string	"Success\n"
.LC3:
	.string	"Failed\n"
	.data
	.global	t0
	.align	4
	.type	t0, @object
t0:
	.zero	4
	.global	t1
	.align	4
	.type	t1, @object
t1:
	.zero	4
	.global	t2
	.align	4
	.type	t2, @object
t2:
	.zero	4


# your asm code here
	.text
	.globl main
	.type	main, @function
main:
	pushl	%ebp
	movl	%esp, %ebp

	movl	a, t0
	subl	$8, %esp
	pushl	$t0
	pushl	$.LC0
	call	scanf
	addl	$16, %esp
	movl	b, t1
	subl	$8, %esp
	pushl	$t1
	pushl	$.LC1
	call	scanf
	addl	$16, %esp
	testl	t2, t2
	jle	.L0
	subl	$12, %esp
	pushl	$.LC2
	call	printf
	addl	$16, %esp
	jmp .L2
.L0:
	subl	$12, %esp
	pushl	$.LC3
	call	printf
	addl	$16, %esp
.L2:
	movl	$0, %eax
	popl	%ebp
	ret
	.section	.note.GNU-stack,,@progbits
